<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>using_services_with_cxx.md / Apache Celix</title>

    <!-- Bootstrap core CSS -->
    <link href="/assets/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom style -->
    <link href="/assets/css/style.css" rel="stylesheet">
</head>
<body class="light-grey">

<a href="https://github.com/apache/celix" class="github-ribbon">
    <img src="/assets/img/forkme_right_red_aa0000.png" alt="Fork me on GitHub">
</a>

<!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top">
    <div class="container">
        <a class="navbar-brand" href="/">
            <img src="/assets/img/celix-white.svg" height="40" class="d-inline-block align-top" alt="Celix Logo">
        </a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
            <ul class="navbar-nav ml-auto">
                <li class="nav-item">
                    <a class="nav-link" href="/">Home</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="/download.cgi">Download</a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="/docs/">Docs</a>
                </li>
                <li class="nav-item dropdown">
                    <a class="nav-link dropdown-toggle" href="#" id="ddCommunity" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        Community
                    </a>
                    <div class="dropdown-menu" aria-labelledby="ddCommunity">
                        <a class="dropdown-item" href="/contributing/youatcelix.html">You at Celix</a>
                        <a class="dropdown-item" href="/contributing/submitting-patches.html">Submitting patches</a>
                        <a class="dropdown-item" href="/contributing/releasing.html">Releasing</a>
                        <a class="dropdown-item" href="/contributing/volunteers.html">Volunteers</a>
                        <a class="dropdown-item" href="https://whimsy.apache.org/board/minutes/Celix.html">Board Reports</a>
                    </div>
                </li>
                <li class="nav-item dropdown">
                    <a class="nav-link dropdown-toggle" href="#" id="ddSupport" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        Support
                    </a>
                    <div class="dropdown-menu" aria-labelledby="ddSupport">
                        <a class="dropdown-item" href="/support/mailing-list.html">Mailing Lists</a>
                        <a class="dropdown-item" href="/support/issue-tracking.html">Issue Tracking</a>
                    </div>
                </li>
                <li class="nav-item dropdown">
                    <a class="nav-link dropdown-toggle" href="#" id="ddFoundation" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                        ASF
                    </a>
                    <div class="dropdown-menu" aria-labelledby="ddFoundation">
                        <a class="dropdown-item" href="https://www.apache.org/">ASF Home</a>
                        <a class="dropdown-item" href="https://www.apache.org/foundation/how-it-works.html">How it works</a>
                        <a class="dropdown-item" href="https://www.apache.org/licenses/">License</a>
                        <a class="dropdown-item" href="https://www.apache.org/foundation/sponsorship.html">Sponsorship</a>
                        <a class="dropdown-item" href="https://www.apache.org/foundation/thanks.html">Thanks</a>
                        <a class="dropdown-item" href="https://www.apache.org/security/">Security</a>
                    </div>
                </li>
            </ul>
        </div>
    </div>
</nav>


<div class="section">
    <div class="container">
        <div class="row py-4">
            <div class="col-sm-12 card">
                <div class="card-body pt-5">
                    <a class="edit-on-gh" href="https://github.com/apache/celix/edit/develop/documents/getting_started/using_services_with_cxx.md" title="Edit this page on GitHub">Edit on GitHub</a>
                    <a href="/docs/" title="back to documentation">&lt;&lt; back to documentation</a>

                    <!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at
   
    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<h1 id="apache-celix---using-services-with-c">Apache Celix - Using Services with C++</h1>

<h2 id="intro">Intro</h2>

<p>This example gives an overview for providing and using C and C++ services with Apache Celix with C++.</p>

<h2 id="services">Services</h2>

<h3 id="c-services">C++ Services</h3>
<p>To start of, C++ service in Celix are just (abstract) classes.</p>

<p>In the following example there also a projected default constructor and destructor to ensure no instantiation / deletion of the service is possible:</p>
<pre><code class="language-C++">#ifndef IANOTHER_EXAMPLE_H
#define IANOTHER_EXAMPLE_H

#define IANOTHER_EXAMPLE_VERSION "1.0.0"
#define IANOTHER_EXAMPLE_CONSUMER_RANGE "[1.0.0,2.0.0)"

class IAnotherExample {
protected:
    IAnotherExample() = default;
    virtual ~IAnotherExample() = default;
public:
    virtual double method(int arg1, double arg2) = 0;
};

#endif //IANOTHER_EXAMPLE_H
</code></pre>

<p>For a Celix service a service name, service provider version and service consumer range should be declared.
This is explicitly done with macros to prevent symbols so to that no linking dependencies are introduced. 
For C++ the service name can be inferred.</p>

<h3 id="c-services-1">C Services</h3>
<p>C services in Celix are just a pointer to a memory location registered in the service registry using a name and an optional set of key/value pairs.</p>

<p>By convention use the following service layout:</p>
<pre><code class="language-C">//example.h
#ifndef EXAMPLE_H_
#define EXAMPLE_H_

#ifdef __cplusplus
extern "C" {
#endif

#define EXAMPLE_NAME 			"org.example"
#define EXAMPLE_VERSION 		"1.0.0"
#define EXAMPLE_CONSUMER_RANGE   "[1.0.0,2.0.0)"


struct example_struct {
	void *handle;
	int (*method)(void *handle, int arg1, double arg2, double *result);
} ;

typedef struct example_struct example_t;

#ifdef __cplusplus
}
#endif

#endif /* EXAMPLE_H_ */
</code></pre>

<p>For C service a struct containing the function pointers needs to be declared.
The first element of the service struct should be a handle which can be used to store the service context, as convention we keep this pointer a void pointer to explicitly make it opaque.
Note that also an opaque struct could be used (e.g a declared but not defined struct), but this can become problematic concerning components registering multiple services. 
In that case explicit cast are needed to prevent warning and this can be confusing for the To prevent that issues void pointers are preferred.</p>

<p>The rest of the element should be function pointers, which by convention should return an celix_status_t or int (which is technically the same). 
The return value is used as a way of handling errors and is also needed to be able to make remote services (e.g. to be able to handle remote exceptions).</p>

<p>The first argument of a service function should be the service handle and if there is a result the last argument should be a output parameter (either pre allocated (e.g. double *) or not (e.g. double <strong>)).
If the caller is not the owner of the output argument, a const pointer should be used (e.g. const char</strong>). 
It is also possible to create typedef of the pointer to the service struct (e.g. typedef struct example_struct example_t), but this is not needed.</p>

<p>In the Celix code base there are still service which uses a typedef with a pointer (e.g. typedef struct example_struct* example_struct_pt). This should be avoided, 
because it is not possible to create the const pointer of those typedefs and it is not possible to include those typedef inside a existing struct without the needed for an additional malloc.</p>

<h3 id="semantic-versioning">Semantic Versioning</h3>
<p>For versioning, semantic versioning should be used.</p>

<p>A backward incompatible change should lead to a major version increase (e.g. 1.0.0 -&gt; 2.0.0).</p>

<h3 id="versioning-c-services">Versioning C++ Services</h3>
<p>For C++ Services versioning is used ot express binary compatibility changes that are incompatible are:</p>

<ul>
  <li>Everything. Seriously, binary compatibility in C++ is difficult and should be avoided.</li>
</ul>

<p>Note that is is possible to use versioning for source compatibility and setup the build environment accordingly, but this is not part of this guide.</p>

<h3 id="versioning-c-services-1">Versioning C Services</h3>
<p>For C Services versioning is used to express binary compatibility (for the same platform / compiler), change that are incompatible are:</p>

<ul>
  <li>Removing a function</li>
  <li>Adding a function to before any other function</li>
  <li>Moving a function to an other location in the service struct</li>
  <li>Changing the signature of a function</li>
  <li>Changing the semantics of a argument (e.g. changing range input from “range in kilometer” to “range in meters”)</li>
</ul>

<p>A backwards binary compatible change which extend the functionality should lead to a minor version increase (e.g. 1.0.0 -&gt; 1.1.0).
Changes considered backwards compatible which extend the functionality are:</p>

<ul>
  <li>Adding a function to the back of the service struct</li>
</ul>

<p>A backwards binary compatible change which does not extend the functionality should lead to a micro version increase (e.g. 1.0.0 -&gt; 1.0.1).
Changes considered backwards binary compatible which does not extend the functionality are:</p>

<ul>
  <li>Changes in the documentation</li>
  <li>Renaming of arguments</li>
</ul>

<p>For C services generally platform specific calling convention are used therefore binary compatibility between service provider and consumers from different compilers is possible (e.g. gcc and clang), 
 but not advisable</p>

<h2 id="components">Components</h2>

<p>Component are concrete classes in C++. This do not have to implement specific interface, expect the C++ service interfaces they provide.</p>

<h2 id="code-examples">Code Examples</h2>

<p>The next code blocks contains some code examples of components to indicate how to handle service dependencies, how to specify providing services and how to cope with locking/synchronizing.
The complete example can be found <a href="../../examples/services_example_cxx">here</a>.</p>

<h3 id="bar-example">Bar Example</h3>

<p>The Bar example is a simple component providing the C <code class="highlighter-rouge">example</code> service and C++ <code class="highlighter-rouge">IAnotherExample</code> service.</p>

<p>Note that the <code class="highlighter-rouge">Bar</code> component is just a plain old C++ object and does need to implement any specific Celix interfaces.</p>

<p>The <code class="highlighter-rouge">BarActivator</code> is the entry point for a C++ bundle. It must implement the <code class="highlighter-rouge">DmActivator::create</code> method so that C++ Dependency manager can create a instance <code class="highlighter-rouge">DmActivator</code> without needing to known the subclass. 
It should also override the <code class="highlighter-rouge">DmActivator::init</code> to be able to declaratively program components and their provided service and service dependencies.</p>

<p>The C++ Dependency Manager can use C++ member function pointers to control the component lifecycle (<code class="highlighter-rouge">init</code>, <code class="highlighter-rouge">start</code>, <code class="highlighter-rouge">stop</code> and <code class="highlighter-rouge">deinit</code>)</p>

<pre><code class="language-C++">//Bar.h
#ifndef BAR_H
#define BAR_H

#include "IAnotherExample.h"

class Bar : public IAnotherExample {
    const double seed = 42;
public:
    Bar() = default;
    virtual ~Bar() = default;

    void init();
    void start();
    void stop();
    void deinit();

    virtual double method(int arg1, double arg2) override; //implementation of IAnotherExample::method
    int cMethod(int arg1, double arg2, double *out); //implementation of example_t-&gt;method;
};

#endif //BAR_H
</code></pre>

<pre><code class="language-C++">//BarActivator.h
#ifndef BAR_ACTIVATOR_H
#define BAR_ACTIVATOR_H

#include "celix/dm/DmActivator.h"
#include "example.h"

using namespace celix::dm;

class BarActivator : public DmActivator {
private:
    example_t cExample {nullptr, nullptr};
public:
    BarActivator(DependencyManager&amp; mng) : DmActivator(mng) {}
    virtual void init() override;
};

#endif //BAR_ACTIVATOR_H
</code></pre>

<pre><code class="language-C++">//Bar.cc
#include "Bar.h"
#include &lt;iostream&gt;

void Bar::init() {
    std::cout &lt;&lt; "init Bar\n";
}

void Bar::start() {
    std::cout &lt;&lt; "start Bar\n";
}

void Bar::stop() {
    std::cout &lt;&lt; "stop Bar\n";
}

void Bar::deinit() {
    std::cout &lt;&lt; "deinit Bar\n";
}

double Bar::method(int arg1, double arg2) {
    double update = (this-&gt;seed + arg1) * arg2;
    return update;
}

int Bar::cMethod(int arg1, double arg2, double *out) {
    double r = this-&gt;method(arg1, arg2);
    *out = r;
    return 0;
}
</code></pre>

<pre><code class="language-C++">//BarActivator.cc
#include "Bar.h"
#include "BarActivator.h"

using namespace celix::dm;

DmActivator* DmActivator::create(DependencyManager&amp; mng) {
    return new BarActivator(mng);
}

void BarActivator::init() {
    std::shared_ptr&lt;Bar&gt; bar = std::shared_ptr&lt;Bar&gt;{new Bar{}};

    Properties props;
    props["meta.info.key"] = "meta.info.value";

    Properties cProps;
    cProps["also.meta.info.key"] = "also.meta.info.value";

    this-&gt;cExample.handle = bar.get();
    this-&gt;cExample.method = [](void *handle, int arg1, double arg2, double *out) {
        Bar* bar = static_cast&lt;Bar*&gt;(handle);
        return bar-&gt;cMethod(arg1, arg2, out);
    };

    mng.createComponent(bar)  //using a pointer a instance. Also supported is lazy initialization (default constructor needed) or a rvalue reference (move)
        .addInterface&lt;IAnotherExample&gt;(IANOTHER_EXAMPLE_VERSION, props)
        .addCInterface(&amp;this-&gt;cExample, EXAMPLE_NAME, EXAMPLE_VERSION, cProps)
        .setCallbacks(&amp;Bar::init, &amp;Bar::start, &amp;Bar::stop, &amp;Bar::deinit);
}
</code></pre>

<h3 id="foo-example">Foo Example</h3>

<p>The <code class="highlighter-rouge">Foo</code> example has a dependency to the C++ and C services provider by the <code class="highlighter-rouge">Bar</code> component. Note that it depends on the services and not directly on the Bar component.</p>

<pre><code class="language-C++">//Foo.h
#ifndef FOO_H
#define FOO_H

#include "example.h"
#include "IAnotherExample.h"
#include &lt;thread&gt;

class Foo  {
    IAnotherExample* example {nullptr};
    const example_t* cExample {nullptr};
    std::thread pollThread {};
    bool running = false;
public:
    Foo() = default;
    virtual ~Foo() = default;

    void start();
    void stop();

    void setAnotherExample(IAnotherExample* e);
    void setExample(const example_t* e);

    void poll();
};

#endif //FOO_H
</code></pre>

<pre><code class="language-C++">//FooActivator.h
#ifndef FOO_ACTIVATOR_H
#define FOO_ACTIVATOR_H

#include "celix/dm/DmActivator.h"

using namespace celix::dm;

class FooActivator : public DmActivator {
private:
public:
    FooActivator(DependencyManager&amp; mng) : DmActivator(mng) {}
    virtual void init() override;
};

#endif //FOO_ACTIVATOR_H
</code></pre>

<pre><code class="language-C++">//Foo.cc
#include "Foo.h"
#include &lt;iostream&gt;

void Foo::start() {
    std::cout &lt;&lt; "start Foo\n";
    this-&gt;running = true;
    pollThread = std::thread {&amp;Foo::poll, this};
}

void Foo::stop() {
    std::cout &lt;&lt; "stop Foo\n";
    this-&gt;running = false;
    this-&gt;pollThread.join();
}

void Foo::setAnotherExample(IAnotherExample *e) {
    this-&gt;example = e;
}

void Foo::setExample(const example_t *e) {
    this-&gt;cExample = e;
}

void Foo::poll() {
    double r1 = 1.0;
    double r2 = 1.0;
    while (this-&gt;running) {
        //c++ service required -&gt; if component started always available
        r1 = this-&gt;example-&gt;method(3, r1);
        std::cout &lt;&lt; "Result IAnotherExample is " &lt;&lt; r1 &lt;&lt; "\n";

        //c service is optional, can be nullptr
        if (this-&gt;cExample != nullptr) {
            double out;
            this-&gt;cExample-&gt;method(this-&gt;cExample-&gt;handle, 4, r2, &amp;out);
            r2 = out;
            std::cout &lt;&lt; "Result example_t is " &lt;&lt; r2 &lt;&lt; "\n";
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(5000));
    }
}
</code></pre>

<pre><code class="language-C++">//FooActivator.cc
#include "Foo.h"
#include "FooActivator.h"

using namespace celix::dm;

DmActivator* DmActivator::create(DependencyManager&amp; mng) {
    return new FooActivator(mng);
}

void FooActivator::init() {

    Component&lt;Foo&gt;&amp; cmp = mng.createComponent&lt;Foo&gt;()
        .setCallbacks(nullptr, &amp;Foo::start, &amp;Foo::stop, nullptr);

    cmp.createServiceDependency&lt;IAnotherExample&gt;()
            .setRequired(true)
            .setVersionRange(IANOTHER_EXAMPLE_CONSUMER_RANGE)
            .setCallbacks(&amp;Foo::setAnotherExample);

    cmp.createCServiceDependency&lt;example_t&gt;(EXAMPLE_NAME)
            .setRequired(false)
            .setVersionRange(EXAMPLE_CONSUMER_RANGE)
            .setCallbacks(&amp;Foo::setExample);
}
</code></pre>

<h3 id="baz-example">Baz Example</h3>

<p>The <code class="highlighter-rouge">Baz</code> example has a dependency to the C++ and C services provider by the <code class="highlighter-rouge">Bar</code> component, 
but uses the add / remove callbacks instead of set and as result is able to depend on multiple instance of a declared service dependencies.</p>

<pre><code class="language-C++">//Baz.h
#ifndef BAZ_H
#define BAZ_H

#include "example.h"
#include "IAnotherExample.h"
#include &lt;thread&gt;
#include &lt;list&gt;
#include &lt;mutex&gt;

class Baz  {
    std::list&lt;IAnotherExample*&gt; examples {};
    std::mutex lock_for_examples {};

    std::list&lt;const example_t*&gt; cExamples {};
    std::mutex lock_for_cExamples {};

    std::thread pollThread {};
    bool running = false;
public:
    Baz() = default;
    virtual ~Baz() = default;

    void start();
    void stop();

    void addAnotherExample(IAnotherExample* e);
    void removeAnotherExample(IAnotherExample* e);

    void addExample(const example_t* e);
    void removeExample(const example_t* e);

    void poll();
};

#endif //BAZ_H
</code></pre>

<pre><code class="language-C++">//BazActivator.h
#ifndef BAZ_ACTIVATOR_H
#define BAZ_ACTIVATOR_H

#include "celix/dm/DmActivator.h"

using namespace celix::dm;

class BazActivator : public DmActivator {
private:
public:
    BazActivator(DependencyManager&amp; mng) : DmActivator(mng) {}
    virtual void init() override;
};

#endif //BAZ_ACTIVATOR_H
</code></pre>

<pre><code class="language-C++">//Baz.cc
#include "Baz.h"
#include &lt;iostream&gt;

void Baz::start() {
    std::cout &lt;&lt; "start Baz\n";
    this-&gt;running = true;
    pollThread = std::thread {&amp;Baz::poll, this};
}

void Baz::stop() {
    std::cout &lt;&lt; "stop Baz\n";
    this-&gt;running = false;
    this-&gt;pollThread.join();
}

void Baz::addAnotherExample(IAnotherExample *e) {
    std::lock_guard&lt;std::mutex&gt; lock(this-&gt;lock_for_examples);
    this-&gt;examples.push_back(e);
}

void Baz::removeAnotherExample(IAnotherExample *e) {
    std::lock_guard&lt;std::mutex&gt; lock(this-&gt;lock_for_examples);
    this-&gt;examples.remove(e);
}

void Baz::addExample(const example_t *e) {
    std::lock_guard&lt;std::mutex&gt; lock(this-&gt;lock_for_cExamples);
    this-&gt;cExamples.push_back(e);
}

void Baz::removeExample(const example_t *e) {
    std::lock_guard&lt;std::mutex&gt; lock(this-&gt;lock_for_cExamples);
    this-&gt;cExamples.remove(e);
}

void Baz::poll() {
    double r1 = 1.0;
    double r2 = 1.0;
    while (this-&gt;running) {
        //c++ service required -&gt; if component started always available

        {
            std::lock_guard&lt;std::mutex&gt; lock(this-&gt;lock_for_examples);
            int index = 0;
            for (IAnotherExample *e : this-&gt;examples) {
                r1 = e-&gt;method(3, r1);
                std::cout &lt;&lt; "Result IAnotherExample " &lt;&lt; index++ &lt;&lt; " is " &lt;&lt; r1 &lt;&lt; "\n";
            }
        }


        {
            std::lock_guard&lt;std::mutex&gt; lock(this-&gt;lock_for_cExamples);
            int index = 0;
            for (const example_t *e : this-&gt;cExamples) {
                double out;
                e-&gt;method(e-&gt;handle, 4, r2, &amp;out);
                r2 = out;
                std::cout &lt;&lt; "Result example_t " &lt;&lt; index++ &lt;&lt; " is " &lt;&lt; r2 &lt;&lt; "\n";
            }
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(4000));
    }
}
</code></pre>

<pre><code class="language-C++">//BazActivator.cc
#include "Baz.h"
#include "BazActivator.h"

using namespace celix::dm;

DmActivator* DmActivator::create(DependencyManager&amp; mng) {
    return new BazActivator(mng);
}

void BazActivator::init() {

    Component&lt;Baz&gt;&amp; cmp = mng.createComponent&lt;Baz&gt;()
        .setCallbacks(nullptr, &amp;Baz::start, &amp;Baz::stop, nullptr);

    cmp.createServiceDependency&lt;IAnotherExample&gt;()
            .setRequired(true)
            .setStrategy(DependencyUpdateStrategy::locking)
            .setVersionRange(IANOTHER_EXAMPLE_CONSUMER_RANGE)
            .setCallbacks(&amp;Baz::addAnotherExample, &amp;Baz::removeAnotherExample);

    cmp.createCServiceDependency&lt;example_t&gt;(EXAMPLE_NAME)
            .setRequired(false)
            .setStrategy(DependencyUpdateStrategy::locking)
            .setVersionRange(EXAMPLE_CONSUMER_RANGE)
            .setCallbacks(&amp;Baz::addExample, &amp;Baz::removeExample);
}
</code></pre>

<h2 id="locking-and-suspending">Locking and Suspending</h2>

<p>As you may notice, the Baz example uses locks.
In principle, locking is necessary in order to ensure coherence in case service dependencies are removed/added/changed; on the other hands, locking increases latency and, when misused, can lead to poor performance. 
For this reason, the serviceDependency interface gives the possibility to choose between a locking and suspend (a non-locking) strategy through the serviceDependency_setStrategy function, as is used in the Foo2 example.</p>

<p>The locking strategy <code class="highlighter-rouge">DependencyUpdateStrategy::locking</code> notifies the component in case the dependencies’ set changes (e.g. a dependency is added/removed): the component is responsible for protecting via locks the dependencies’ list and check (always under lock) if the service he’s depending on is still available.
The suspend or non-locking strategy <code class="highlighter-rouge">DependencyUpdateStrategy::suspend</code> (default when no strategy is explicitly set) reliefs the programmer from dealing with service dependencies’ consistency issues: in case this strategy is adopted, the component is stopped and restarted (i.e. temporarily suspended) upon service dependencies’ changes.</p>

<p>The suspend strategy has the advantage of reducing locks’ usage: of course, suspending the component has its own overhead (e.g. stopping and restarting threads), but this overhead is “paid” only in case of changes in service dependencies, while the locking overhead is always paid.</p>

<h2 id="see-also">See also</h2>

<p>See the <a href="../../dependency_manager_cxx/readme.html">C++ Dependeny Manager</a> and <a href="../../examples/dm_example_cxx">C++ Dependency Manager example</a> for more information and a more complex working example.</p>

                </div>
            </div>
        </div>
    </div>
</div>

<!-- Footer -->
<footer class="py-3 bg-secondary">
    <div class="container">
        <p class="m-0 text-center text-white">
            Copyright &copy; 2018 The Apache Software Foundation, Licensed under
            the <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>.
            <br>
            Apache Celix, Celix, Apache, the Apache feather logo and the Apache Celix logo are trademarks of The Apache Software Foundation.
        </p>
    </div>
</footer>

<!-- Bootstrap core JavaScript -->
<script src="/assets/js/jquery.min.js"></script>
<script src="/assets/js/bootstrap.bundle.min.js"></script>


</body>
</html>
